if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-180
in.meanpay<-200
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-180
in.meanpay<-200
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-180
in.meanpay<-200
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-180
in.meanpay<-200
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-80
in.meanpay<-100
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-130
in.meanpay<-150
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-130
in.meanpay<-150
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-135
in.meanpay<-150
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-135
in.meanpay<-150
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-135
in.meanpay<-150
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-135
in.meanpay<-150
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
source("jarabe.R")
pay.out<-135
in.meanpay<-150
thres<-pay.out-in.meanpay
n<-200
rho<-.85
ser<-20
p1<-seq(n)
epsi<-rnorm(n)*ser
xini<-0
xse<-rep(NA,n)
xse[1]<-xini
for(i in seq(2,n)){
xse[i] = rho*xse[i-1]  + epsi[i]
}
xf<-fmt.o.forecast(xse,.13,rho,.42,2)
plot(xse+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(c(NA,NA,NA,NA,xf+in.meanpay),col="red",lty=2)
abline(h=pay.out)
## We analyze whether player following FMT decides IN or OUT
state.in<-rep(NA,length(xse))
state.in[1:4]<-1
beliefs<-rep(NA,length(xse)) #this vector fills the missing values with the RE belief
fmt.beliefs<-rep(NA,length(xse)) #this vector stores FMT beliefs
beliefs[1:4]<-xse[1:4]
fmt.beliefs[1:4]<-xse[1:4]
for(t in seq(4,(length(xse)-1))){
if(state.in[t]==0){
beliefs[t]<- rho*beliefs[t-1]}
else
{beliefs[t]<- xse[t]}
xf_u<-fmt.u.forecast(beliefs[1:t],state.in[1:t],.13,rho,.42,2)
fmt.beliefs[t]<-xf_u
state.in[t+1]<-fmt.decision(xf_u, thres)
}
count.out<-sum(state.in==0)/n
count.out
plot(fmt.beliefs+in.meanpay, type="l",lwd=2,ylim=c(0,300))
lines(xse+in.meanpay, col="red")
abline(h=pay.out)
3.07*1.90
(256+64*2)/3
(64+8*2)/3
8/3
56/8
4*2/3+8*1/3
16*2/3+8*1/3
5.333333*1/3+13.33333*2/3
224/27
64-16
48/32
32*1.5*2-32*.5
32*1.5*2-32*.5
32*1.5*.5-32*.5
1.5/.5
(832/17)/(1280/81)
3000*.7*.75
30000*.7*.75
30000*.7
